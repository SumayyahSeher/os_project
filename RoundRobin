class RoundRobin:
    def __init__(self):
        pass

    def processData(self, no_of_processes):
        process_data = []
        for i in range(no_of_processes):
            process_id = i + 1
            arrival_time = int(input(f"Enter Arrival Time for Process {process_id}: "))
            burst_time = int(input(f"Enter Burst Time for Process {process_id}: "))
            process_data.append([process_id, arrival_time, burst_time, 0, burst_time])  # 0: not executed, 1: executed

        time_slice = int(input("Enter Time Slice: "))
        self.schedulingProcess(process_data, time_slice)

    def drawGanttChart(self, process_data, executed_process, start_time, exit_time):
        print("\nGantt Chart:")
        for process_id in executed_process:
            print(f"| P{process_id} ", end="")
        print("|")

        for i in range(len(start_time)):
            print(f"{start_time[i]:^{exit_time[i] - start_time[i]}}", end=" ")
        print("\n")

    def schedulingProcess(self, process_data, time_slice):
        start_time = []
        exit_time = []
        executed_process = []
        ready_queue = []
        time = 0

        process_data.sort(key=lambda x: x[1])  # Sort by arrival time

        while True:
            # Add processes to ready queue if they've arrived
            for i in range(len(process_data)):
                if process_data[i][1] <= time and process_data[i][3] == 0:
                    ready_queue.append(i)
                    process_data[i][3] = 1  # Mark as in ready queue

            if not ready_queue:
                # If ready queue is empty, find the next arrival time
                next_arrival = min([p[1] for p in process_data if p[3] == 0])
                time = next_arrival
                continue

            current_process = ready_queue.pop(0)
            remaining_time = process_data[current_process][2]

            if remaining_time <= time_slice:
                # Process finishes in this time slice
                start_time.append(time)
                time += remaining_time
                exit_time.append(time)
                executed_process.append(process_data[current_process][0])
                process_data[current_process][2] = 0  # Mark as finished
                process_data[current_process][4] = time  # Completion time
            else:
                # Process doesn't finish in this time slice
                start_time.append(time)
                time += time_slice
                exit_time.append(time)
                executed_process.append(process_data[current_process][0])
                process_data[current_process][2] -= time_slice
                ready_queue.append(current_process)  # Add back to ready queue

            # Check if all processes are finished
            if all(p[2] == 0 for p in process_data):
                break

        self.calculateAndPrintResults(process_data, executed_process, start_time, exit_time)

    def calculateAndPrintResults(self, process_data, executed_process, start_time, exit_time):
        for process in process_data:
            process.append(process[4] - process[1])  # Turnaround time
            process.append(process[5] - process[4])  # Waiting time

        avg_turnaround_time = sum(p[5] for p in process_data) / len(process_data)
        avg_waiting_time = sum(p[6] for p in process_data) / len(process_data)

        process_data.sort(key=lambda x: x[0])
        print("\nProcess ID\tArrival Time\tBurst Time\tCompletion Time\tTurnaround Time\tWaiting Time")
        for process in process_data:
            for i in range(len(process)):
                print(process[i], end="\t")
            print()

        print(f"Average Turnaround Time: {avg_turnaround_time:.2f}")
        print(f"Average Waiting Time: {avg_waiting_time:.2f}")
        print(f"Sequence of Processes: {executed_process}")
        self.drawGanttChart(process_data, executed_process, start_time, exit_time)

if __name__ == "__main__":
    no_of_processes = int(input("Enter number of processes: "))
    rr = RoundRobin()
    rr.processData(no_of_processes)
